"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/teeny-request";
exports.ids = ["vendor-chunks/teeny-request"];
exports.modules = {

/***/ "(rsc)/./node_modules/teeny-request/build/src/TeenyStatistics.js":
/*!*****************************************************************!*\
  !*** ./node_modules/teeny-request/build/src/TeenyStatistics.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TeenyStatistics = exports.TeenyStatisticsWarning = void 0;\n/**\n * @class TeenyStatisticsWarning\n * @extends Error\n * @description While an error, is used for emitting warnings when\n *   meeting certain configured thresholds.\n * @see process.emitWarning\n */\nclass TeenyStatisticsWarning extends Error {\n    static CONCURRENT_REQUESTS = 'ConcurrentRequestsExceededWarning';\n    threshold = 0;\n    type = '';\n    value = 0;\n    /**\n     * @param {string} message\n     */\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nexports.TeenyStatisticsWarning = TeenyStatisticsWarning;\n/**\n * @class TeenyStatistics\n * @description Maintain various statistics internal to teeny-request. Tracking\n *   is not automatic and must be instrumented within teeny-request.\n */\nclass TeenyStatistics {\n    /**\n     * @description A default threshold representing when to warn about excessive\n     *   in-flight/concurrent requests.\n     * @type {number}\n     * @static\n     * @readonly\n     * @default 5000\n     */\n    static DEFAULT_WARN_CONCURRENT_REQUESTS = 5000;\n    /**\n     * @type {TeenyStatisticsConfig}\n     * @private\n     */\n    _options;\n    /**\n     * @type {number}\n     * @private\n     * @default 0\n     */\n    _concurrentRequests = 0;\n    /**\n     * @type {boolean}\n     * @private\n     * @default false\n     */\n    _didConcurrentRequestWarn = false;\n    /**\n     * @param {TeenyStatisticsOptions} [opts]\n     */\n    constructor(opts) {\n        this._options = TeenyStatistics._prepareOptions(opts);\n    }\n    /**\n     * Returns a copy of the current options.\n     * @return {TeenyStatisticsOptions}\n     */\n    getOptions() {\n        return Object.assign({}, this._options);\n    }\n    /**\n     * Change configured statistics options. This will not preserve unspecified\n     *   options that were previously specified, i.e. this is a reset of options.\n     * @param {TeenyStatisticsOptions} [opts]\n     * @returns {TeenyStatisticsConfig} The previous options.\n     * @see _prepareOptions\n     */\n    setOptions(opts) {\n        const oldOpts = this._options;\n        this._options = TeenyStatistics._prepareOptions(opts);\n        return oldOpts;\n    }\n    /**\n     * @readonly\n     * @return {TeenyStatisticsCounters}\n     */\n    get counters() {\n        return {\n            concurrentRequests: this._concurrentRequests,\n        };\n    }\n    /**\n     * @description Should call this right before making a request.\n     */\n    requestStarting() {\n        this._concurrentRequests++;\n        if (this._options.concurrentRequests > 0 &&\n            this._concurrentRequests >= this._options.concurrentRequests &&\n            !this._didConcurrentRequestWarn) {\n            this._didConcurrentRequestWarn = true;\n            const warning = new TeenyStatisticsWarning('Possible excessive concurrent requests detected. ' +\n                this._concurrentRequests +\n                ' requests in-flight, which exceeds the configured threshold of ' +\n                this._options.concurrentRequests +\n                '. Use the TEENY_REQUEST_WARN_CONCURRENT_REQUESTS environment ' +\n                'variable or the concurrentRequests option of teeny-request to ' +\n                'increase or disable (0) this warning.');\n            warning.type = TeenyStatisticsWarning.CONCURRENT_REQUESTS;\n            warning.value = this._concurrentRequests;\n            warning.threshold = this._options.concurrentRequests;\n            process.emitWarning(warning);\n        }\n    }\n    /**\n     * @description When using `requestStarting`, call this after the request\n     *   has finished.\n     */\n    requestFinished() {\n        // TODO negative?\n        this._concurrentRequests--;\n    }\n    /**\n     * Configuration Precedence:\n     *   1. Dependency inversion via defined option.\n     *   2. Global numeric environment variable.\n     *   3. Built-in default.\n     * This will not preserve unspecified options previously specified.\n     * @param {TeenyStatisticsOptions} [opts]\n     * @returns {TeenyStatisticsOptions}\n     * @private\n     */\n    static _prepareOptions({ concurrentRequests: diConcurrentRequests, } = {}) {\n        let concurrentRequests = this.DEFAULT_WARN_CONCURRENT_REQUESTS;\n        const envConcurrentRequests = Number(process.env.TEENY_REQUEST_WARN_CONCURRENT_REQUESTS);\n        if (diConcurrentRequests !== undefined) {\n            concurrentRequests = diConcurrentRequests;\n        }\n        else if (!Number.isNaN(envConcurrentRequests)) {\n            concurrentRequests = envConcurrentRequests;\n        }\n        return { concurrentRequests };\n    }\n}\nexports.TeenyStatistics = TeenyStatistics;\n//# sourceMappingURL=TeenyStatistics.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9idWlsZC9zcmMvVGVlbnlTdGF0aXN0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBNEMsSUFBSTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFuaXNoLWxhbmd1YWdlLWxlYXJuaW5nLWFwcC8uL25vZGVfbW9kdWxlcy90ZWVueS1yZXF1ZXN0L2J1aWxkL3NyYy9UZWVueVN0YXRpc3RpY3MuanM/MjJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRlZW55U3RhdGlzdGljcyA9IGV4cG9ydHMuVGVlbnlTdGF0aXN0aWNzV2FybmluZyA9IHZvaWQgMDtcbi8qKlxuICogQGNsYXNzIFRlZW55U3RhdGlzdGljc1dhcm5pbmdcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAZGVzY3JpcHRpb24gV2hpbGUgYW4gZXJyb3IsIGlzIHVzZWQgZm9yIGVtaXR0aW5nIHdhcm5pbmdzIHdoZW5cbiAqICAgbWVldGluZyBjZXJ0YWluIGNvbmZpZ3VyZWQgdGhyZXNob2xkcy5cbiAqIEBzZWUgcHJvY2Vzcy5lbWl0V2FybmluZ1xuICovXG5jbGFzcyBUZWVueVN0YXRpc3RpY3NXYXJuaW5nIGV4dGVuZHMgRXJyb3Ige1xuICAgIHN0YXRpYyBDT05DVVJSRU5UX1JFUVVFU1RTID0gJ0NvbmN1cnJlbnRSZXF1ZXN0c0V4Y2VlZGVkV2FybmluZyc7XG4gICAgdGhyZXNob2xkID0gMDtcbiAgICB0eXBlID0gJyc7XG4gICAgdmFsdWUgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG59XG5leHBvcnRzLlRlZW55U3RhdGlzdGljc1dhcm5pbmcgPSBUZWVueVN0YXRpc3RpY3NXYXJuaW5nO1xuLyoqXG4gKiBAY2xhc3MgVGVlbnlTdGF0aXN0aWNzXG4gKiBAZGVzY3JpcHRpb24gTWFpbnRhaW4gdmFyaW91cyBzdGF0aXN0aWNzIGludGVybmFsIHRvIHRlZW55LXJlcXVlc3QuIFRyYWNraW5nXG4gKiAgIGlzIG5vdCBhdXRvbWF0aWMgYW5kIG11c3QgYmUgaW5zdHJ1bWVudGVkIHdpdGhpbiB0ZWVueS1yZXF1ZXN0LlxuICovXG5jbGFzcyBUZWVueVN0YXRpc3RpY3Mge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGRlZmF1bHQgdGhyZXNob2xkIHJlcHJlc2VudGluZyB3aGVuIHRvIHdhcm4gYWJvdXQgZXhjZXNzaXZlXG4gICAgICogICBpbi1mbGlnaHQvY29uY3VycmVudCByZXF1ZXN0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAZGVmYXVsdCA1MDAwXG4gICAgICovXG4gICAgc3RhdGljIERFRkFVTFRfV0FSTl9DT05DVVJSRU5UX1JFUVVFU1RTID0gNTAwMDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VGVlbnlTdGF0aXN0aWNzQ29uZmlnfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29wdGlvbnM7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBfY29uY3VycmVudFJlcXVlc3RzID0gMDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgX2RpZENvbmN1cnJlbnRSZXF1ZXN0V2FybiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VGVlbnlTdGF0aXN0aWNzT3B0aW9uc30gW29wdHNdXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gVGVlbnlTdGF0aXN0aWNzLl9wcmVwYXJlT3B0aW9ucyhvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtUZWVueVN0YXRpc3RpY3NPcHRpb25zfVxuICAgICAqL1xuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGNvbmZpZ3VyZWQgc3RhdGlzdGljcyBvcHRpb25zLiBUaGlzIHdpbGwgbm90IHByZXNlcnZlIHVuc3BlY2lmaWVkXG4gICAgICogICBvcHRpb25zIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNwZWNpZmllZCwgaS5lLiB0aGlzIGlzIGEgcmVzZXQgb2Ygb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge1RlZW55U3RhdGlzdGljc09wdGlvbnN9IFtvcHRzXVxuICAgICAqIEByZXR1cm5zIHtUZWVueVN0YXRpc3RpY3NDb25maWd9IFRoZSBwcmV2aW91cyBvcHRpb25zLlxuICAgICAqIEBzZWUgX3ByZXBhcmVPcHRpb25zXG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IG9sZE9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gVGVlbnlTdGF0aXN0aWNzLl9wcmVwYXJlT3B0aW9ucyhvcHRzKTtcbiAgICAgICAgcmV0dXJuIG9sZE9wdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEByZXR1cm4ge1RlZW55U3RhdGlzdGljc0NvdW50ZXJzfVxuICAgICAqL1xuICAgIGdldCBjb3VudGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnRSZXF1ZXN0czogdGhpcy5fY29uY3VycmVudFJlcXVlc3RzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvdWxkIGNhbGwgdGhpcyByaWdodCBiZWZvcmUgbWFraW5nIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICByZXF1ZXN0U3RhcnRpbmcoKSB7XG4gICAgICAgIHRoaXMuX2NvbmN1cnJlbnRSZXF1ZXN0cysrO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jb25jdXJyZW50UmVxdWVzdHMgPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9jb25jdXJyZW50UmVxdWVzdHMgPj0gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW50UmVxdWVzdHMgJiZcbiAgICAgICAgICAgICF0aGlzLl9kaWRDb25jdXJyZW50UmVxdWVzdFdhcm4pIHtcbiAgICAgICAgICAgIHRoaXMuX2RpZENvbmN1cnJlbnRSZXF1ZXN0V2FybiA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5nID0gbmV3IFRlZW55U3RhdGlzdGljc1dhcm5pbmcoJ1Bvc3NpYmxlIGV4Y2Vzc2l2ZSBjb25jdXJyZW50IHJlcXVlc3RzIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25jdXJyZW50UmVxdWVzdHMgK1xuICAgICAgICAgICAgICAgICcgcmVxdWVzdHMgaW4tZmxpZ2h0LCB3aGljaCBleGNlZWRzIHRoZSBjb25maWd1cmVkIHRocmVzaG9sZCBvZiAnICtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbnRSZXF1ZXN0cyArXG4gICAgICAgICAgICAgICAgJy4gVXNlIHRoZSBURUVOWV9SRVFVRVNUX1dBUk5fQ09OQ1VSUkVOVF9SRVFVRVNUUyBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgICAgICAgICAndmFyaWFibGUgb3IgdGhlIGNvbmN1cnJlbnRSZXF1ZXN0cyBvcHRpb24gb2YgdGVlbnktcmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgICAgICAnaW5jcmVhc2Ugb3IgZGlzYWJsZSAoMCkgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgd2FybmluZy50eXBlID0gVGVlbnlTdGF0aXN0aWNzV2FybmluZy5DT05DVVJSRU5UX1JFUVVFU1RTO1xuICAgICAgICAgICAgd2FybmluZy52YWx1ZSA9IHRoaXMuX2NvbmN1cnJlbnRSZXF1ZXN0cztcbiAgICAgICAgICAgIHdhcm5pbmcudGhyZXNob2xkID0gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW50UmVxdWVzdHM7XG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBXaGVuIHVzaW5nIGByZXF1ZXN0U3RhcnRpbmdgLCBjYWxsIHRoaXMgYWZ0ZXIgdGhlIHJlcXVlc3RcbiAgICAgKiAgIGhhcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICByZXF1ZXN0RmluaXNoZWQoKSB7XG4gICAgICAgIC8vIFRPRE8gbmVnYXRpdmU/XG4gICAgICAgIHRoaXMuX2NvbmN1cnJlbnRSZXF1ZXN0cy0tO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIFByZWNlZGVuY2U6XG4gICAgICogICAxLiBEZXBlbmRlbmN5IGludmVyc2lvbiB2aWEgZGVmaW5lZCBvcHRpb24uXG4gICAgICogICAyLiBHbG9iYWwgbnVtZXJpYyBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKiAgIDMuIEJ1aWx0LWluIGRlZmF1bHQuXG4gICAgICogVGhpcyB3aWxsIG5vdCBwcmVzZXJ2ZSB1bnNwZWNpZmllZCBvcHRpb25zIHByZXZpb3VzbHkgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VGVlbnlTdGF0aXN0aWNzT3B0aW9uc30gW29wdHNdXG4gICAgICogQHJldHVybnMge1RlZW55U3RhdGlzdGljc09wdGlvbnN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3ByZXBhcmVPcHRpb25zKHsgY29uY3VycmVudFJlcXVlc3RzOiBkaUNvbmN1cnJlbnRSZXF1ZXN0cywgfSA9IHt9KSB7XG4gICAgICAgIGxldCBjb25jdXJyZW50UmVxdWVzdHMgPSB0aGlzLkRFRkFVTFRfV0FSTl9DT05DVVJSRU5UX1JFUVVFU1RTO1xuICAgICAgICBjb25zdCBlbnZDb25jdXJyZW50UmVxdWVzdHMgPSBOdW1iZXIocHJvY2Vzcy5lbnYuVEVFTllfUkVRVUVTVF9XQVJOX0NPTkNVUlJFTlRfUkVRVUVTVFMpO1xuICAgICAgICBpZiAoZGlDb25jdXJyZW50UmVxdWVzdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVudFJlcXVlc3RzID0gZGlDb25jdXJyZW50UmVxdWVzdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU51bWJlci5pc05hTihlbnZDb25jdXJyZW50UmVxdWVzdHMpKSB7XG4gICAgICAgICAgICBjb25jdXJyZW50UmVxdWVzdHMgPSBlbnZDb25jdXJyZW50UmVxdWVzdHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29uY3VycmVudFJlcXVlc3RzIH07XG4gICAgfVxufVxuZXhwb3J0cy5UZWVueVN0YXRpc3RpY3MgPSBUZWVueVN0YXRpc3RpY3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZWVueVN0YXRpc3RpY3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/build/src/TeenyStatistics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/build/src/agents.js":
/*!********************************************************!*\
  !*** ./node_modules/teeny-request/build/src/agents.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pool = void 0;\nexports.getAgent = getAgent;\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst https_1 = __webpack_require__(/*! https */ \"https\");\n// eslint-disable-next-line n/no-deprecated-api\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nexports.pool = new Map();\n/**\n * Determines if a proxy should be considered based on the environment.\n *\n * @param uri The request uri\n * @returns {boolean}\n */\nfunction shouldUseProxyForURI(uri) {\n    const noProxyEnv = process.env.NO_PROXY || process.env.no_proxy;\n    if (!noProxyEnv) {\n        return true;\n    }\n    const givenURI = new URL(uri);\n    for (const noProxyRaw of noProxyEnv.split(',')) {\n        const noProxy = noProxyRaw.trim();\n        if (noProxy === givenURI.origin || noProxy === givenURI.hostname) {\n            return false;\n        }\n        else if (noProxy.startsWith('*.') || noProxy.startsWith('.')) {\n            const noProxyWildcard = noProxy.replace(/^\\*\\./, '.');\n            if (givenURI.hostname.endsWith(noProxyWildcard)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Returns a custom request Agent if one is found, otherwise returns undefined\n * which will result in the global http(s) Agent being used.\n * @private\n * @param {string} uri The request uri\n * @param {Options} reqOpts The request options\n * @returns {HttpAnyAgent|undefined}\n */\nfunction getAgent(uri, reqOpts) {\n    const isHttp = uri.startsWith('http://');\n    const proxy = reqOpts.proxy ||\n        process.env.HTTP_PROXY ||\n        process.env.http_proxy ||\n        process.env.HTTPS_PROXY ||\n        process.env.https_proxy;\n    const poolOptions = Object.assign({}, reqOpts.pool);\n    const manuallyProvidedProxy = !!reqOpts.proxy;\n    const shouldUseProxy = manuallyProvidedProxy || shouldUseProxyForURI(uri);\n    if (proxy && shouldUseProxy) {\n        // tslint:disable-next-line variable-name\n        const Agent = isHttp\n            ? __webpack_require__(/*! http-proxy-agent */ \"(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/index.js\")\n            : __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/index.js\");\n        const proxyOpts = { ...(0, url_1.parse)(proxy), ...poolOptions };\n        return new Agent(proxyOpts);\n    }\n    let key = isHttp ? 'http' : 'https';\n    if (reqOpts.forever) {\n        key += ':forever';\n        if (!exports.pool.has(key)) {\n            // tslint:disable-next-line variable-name\n            const Agent = isHttp ? http_1.Agent : https_1.Agent;\n            exports.pool.set(key, new Agent({ ...poolOptions, keepAlive: true }));\n        }\n    }\n    return exports.pool.get(key);\n}\n//# sourceMappingURL=agents.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9idWlsZC9zcmMvYWdlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsb0JBQU87QUFDL0I7QUFDQSxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHdHQUFrQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3pDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlDQUFpQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhbmlzaC1sYW5ndWFnZS1sZWFybmluZy1hcHAvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9idWlsZC9zcmMvYWdlbnRzLmpzP2IwMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb29sID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRBZ2VudCA9IGdldEFnZW50O1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBodHRwc18xID0gcmVxdWlyZShcImh0dHBzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG4vbm8tZGVwcmVjYXRlZC1hcGlcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmV4cG9ydHMucG9vbCA9IG5ldyBNYXAoKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHByb3h5IHNob3VsZCBiZSBjb25zaWRlcmVkIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0gdXJpIFRoZSByZXF1ZXN0IHVyaVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZVByb3h5Rm9yVVJJKHVyaSkge1xuICAgIGNvbnN0IG5vUHJveHlFbnYgPSBwcm9jZXNzLmVudi5OT19QUk9YWSB8fCBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICBpZiAoIW5vUHJveHlFbnYpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdpdmVuVVJJID0gbmV3IFVSTCh1cmkpO1xuICAgIGZvciAoY29uc3Qgbm9Qcm94eVJhdyBvZiBub1Byb3h5RW52LnNwbGl0KCcsJykpIHtcbiAgICAgICAgY29uc3Qgbm9Qcm94eSA9IG5vUHJveHlSYXcudHJpbSgpO1xuICAgICAgICBpZiAobm9Qcm94eSA9PT0gZ2l2ZW5VUkkub3JpZ2luIHx8IG5vUHJveHkgPT09IGdpdmVuVVJJLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9Qcm94eS5zdGFydHNXaXRoKCcqLicpIHx8IG5vUHJveHkuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICBjb25zdCBub1Byb3h5V2lsZGNhcmQgPSBub1Byb3h5LnJlcGxhY2UoL15cXCpcXC4vLCAnLicpO1xuICAgICAgICAgICAgaWYgKGdpdmVuVVJJLmhvc3RuYW1lLmVuZHNXaXRoKG5vUHJveHlXaWxkY2FyZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJldHVybnMgYSBjdXN0b20gcmVxdWVzdCBBZ2VudCBpZiBvbmUgaXMgZm91bmQsIG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZFxuICogd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIGdsb2JhbCBodHRwKHMpIEFnZW50IGJlaW5nIHVzZWQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSBUaGUgcmVxdWVzdCB1cmlcbiAqIEBwYXJhbSB7T3B0aW9uc30gcmVxT3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7SHR0cEFueUFnZW50fHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWdlbnQodXJpLCByZXFPcHRzKSB7XG4gICAgY29uc3QgaXNIdHRwID0gdXJpLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKTtcbiAgICBjb25zdCBwcm94eSA9IHJlcU9wdHMucHJveHkgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fFxuICAgICAgICBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8XG4gICAgICAgIHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8XG4gICAgICAgIHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIGNvbnN0IHBvb2xPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxT3B0cy5wb29sKTtcbiAgICBjb25zdCBtYW51YWxseVByb3ZpZGVkUHJveHkgPSAhIXJlcU9wdHMucHJveHk7XG4gICAgY29uc3Qgc2hvdWxkVXNlUHJveHkgPSBtYW51YWxseVByb3ZpZGVkUHJveHkgfHwgc2hvdWxkVXNlUHJveHlGb3JVUkkodXJpKTtcbiAgICBpZiAocHJveHkgJiYgc2hvdWxkVXNlUHJveHkpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHZhcmlhYmxlLW5hbWVcbiAgICAgICAgY29uc3QgQWdlbnQgPSBpc0h0dHBcbiAgICAgICAgICAgID8gcmVxdWlyZSgnaHR0cC1wcm94eS1hZ2VudCcpXG4gICAgICAgICAgICA6IHJlcXVpcmUoJ2h0dHBzLXByb3h5LWFnZW50Jyk7XG4gICAgICAgIGNvbnN0IHByb3h5T3B0cyA9IHsgLi4uKDAsIHVybF8xLnBhcnNlKShwcm94eSksIC4uLnBvb2xPcHRpb25zIH07XG4gICAgICAgIHJldHVybiBuZXcgQWdlbnQocHJveHlPcHRzKTtcbiAgICB9XG4gICAgbGV0IGtleSA9IGlzSHR0cCA/ICdodHRwJyA6ICdodHRwcyc7XG4gICAgaWYgKHJlcU9wdHMuZm9yZXZlcikge1xuICAgICAgICBrZXkgKz0gJzpmb3JldmVyJztcbiAgICAgICAgaWYgKCFleHBvcnRzLnBvb2wuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSB2YXJpYWJsZS1uYW1lXG4gICAgICAgICAgICBjb25zdCBBZ2VudCA9IGlzSHR0cCA/IGh0dHBfMS5BZ2VudCA6IGh0dHBzXzEuQWdlbnQ7XG4gICAgICAgICAgICBleHBvcnRzLnBvb2wuc2V0KGtleSwgbmV3IEFnZW50KHsgLi4ucG9vbE9wdGlvbnMsIGtlZXBBbGl2ZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMucG9vbC5nZXQoa2V5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/build/src/agents.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/teeny-request/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RequestError = void 0;\nexports.teenyRequest = teenyRequest;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst agents_1 = __webpack_require__(/*! ./agents */ \"(rsc)/./node_modules/teeny-request/build/src/agents.js\");\nconst TeenyStatistics_1 = __webpack_require__(/*! ./TeenyStatistics */ \"(rsc)/./node_modules/teeny-request/build/src/TeenyStatistics.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst streamEvents = __webpack_require__(/*! stream-events */ \"(rsc)/./node_modules/stream-events/index.js\");\nconst fetch = (...args) => Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/fetch-blob\"), __webpack_require__.e(\"vendor-chunks/formdata-polyfill\"), __webpack_require__.e(\"vendor-chunks/data-uri-to-buffer\"), __webpack_require__.e(\"vendor-chunks/web-streams-polyfill\"), __webpack_require__.e(\"vendor-chunks/node-domexception\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/src/index.js\")).then(({ default: fetch }) => fetch(...args));\nclass RequestError extends Error {\n    code;\n}\nexports.RequestError = RequestError;\n/**\n * Convert options from Request to Fetch format\n * @private\n * @param reqOpts Request options\n */\nfunction requestToFetchOptions(reqOpts) {\n    const options = {\n        method: reqOpts.method || 'GET',\n        ...(reqOpts.timeout && { timeout: reqOpts.timeout }),\n        ...(typeof reqOpts.gzip === 'boolean' && { compress: reqOpts.gzip }),\n    };\n    if (typeof reqOpts.json === 'object') {\n        // Add Content-type: application/json header\n        reqOpts.headers = reqOpts.headers || {};\n        if (reqOpts.headers instanceof globalThis.Headers) {\n            reqOpts.headers.set('Content-Type', 'application/json');\n        }\n        else {\n            reqOpts.headers['Content-Type'] = 'application/json';\n        }\n        // Set body to JSON representation of value\n        options.body = JSON.stringify(reqOpts.json);\n    }\n    else {\n        if (Buffer.isBuffer(reqOpts.body)) {\n            options.body = reqOpts.body;\n        }\n        else if (typeof reqOpts.body !== 'string') {\n            options.body = JSON.stringify(reqOpts.body);\n        }\n        else {\n            options.body = reqOpts.body;\n        }\n    }\n    if (reqOpts.headers instanceof globalThis.Headers) {\n        options.headers = {};\n        for (const pair of reqOpts.headers.entries()) {\n            options.headers[pair[0]] = pair[1];\n        }\n    }\n    else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        options.headers = reqOpts.headers;\n    }\n    let uri = (reqOpts.uri ||\n        reqOpts.url);\n    if (!uri) {\n        throw new Error('Missing uri or url in reqOpts.');\n    }\n    if (reqOpts.useQuerystring === true || typeof reqOpts.qs === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const qs = __webpack_require__(/*! querystring */ \"querystring\");\n        const params = qs.stringify(reqOpts.qs);\n        uri = uri + '?' + params;\n    }\n    options.agent = (0, agents_1.getAgent)(uri, reqOpts);\n    return { uri, options };\n}\n/**\n * Convert a response from `fetch` to `request` format.\n * @private\n * @param opts The `request` options used to create the request.\n * @param res The Fetch response\n * @returns A `request` response object\n */\nfunction fetchToRequestResponse(opts, res) {\n    const request = {};\n    request.agent = opts.agent || false;\n    request.headers = (opts.headers || {});\n    request.href = res.url;\n    // headers need to be converted from a map to an obj\n    const resHeaders = {};\n    res.headers.forEach((value, key) => (resHeaders[key] = value));\n    const response = Object.assign(res.body, {\n        statusCode: res.status,\n        statusMessage: res.statusText,\n        request,\n        body: res.body,\n        headers: resHeaders,\n        toJSON: () => ({ headers: resHeaders }),\n    });\n    return response;\n}\n/**\n * Create POST body from two parts as multipart/related content-type\n * @private\n * @param boundary\n * @param multipart\n */\nfunction createMultipartStream(boundary, multipart) {\n    const finale = `--${boundary}--`;\n    const stream = new stream_1.PassThrough();\n    for (const part of multipart) {\n        const preamble = `--${boundary}\\r\\nContent-Type: ${part['Content-Type']}\\r\\n\\r\\n`;\n        stream.write(preamble);\n        if (typeof part.body === 'string') {\n            stream.write(part.body);\n            stream.write('\\r\\n');\n        }\n        else {\n            part.body.pipe(stream, { end: false });\n            part.body.on('end', () => {\n                stream.write('\\r\\n');\n                stream.write(finale);\n                stream.end();\n            });\n        }\n    }\n    return stream;\n}\nfunction teenyRequest(reqOpts, callback) {\n    const { uri, options } = requestToFetchOptions(reqOpts);\n    const multipart = reqOpts.multipart;\n    if (reqOpts.multipart && multipart.length === 2) {\n        if (!callback) {\n            // TODO: add support for multipart uploads through streaming\n            throw new Error('Multipart without callback is not implemented.');\n        }\n        const boundary = (0, crypto_1.randomUUID)();\n        options.headers['Content-Type'] =\n            `multipart/related; boundary=${boundary}`;\n        options.body = createMultipartStream(boundary, multipart);\n        // Multipart upload\n        teenyRequest.stats.requestStarting();\n        fetch(uri, options).then(res => {\n            teenyRequest.stats.requestFinished();\n            const header = res.headers.get('content-type');\n            const response = fetchToRequestResponse(options, res);\n            const body = response.body;\n            if (header === 'application/json' ||\n                header === 'application/json; charset=utf-8') {\n                res.json().then(json => {\n                    response.body = json;\n                    callback(null, response, json);\n                }, (err) => {\n                    callback(err, response, body);\n                });\n                return;\n            }\n            res.text().then(text => {\n                response.body = text;\n                callback(null, response, text);\n            }, err => {\n                callback(err, response, body);\n            });\n        }, err => {\n            teenyRequest.stats.requestFinished();\n            callback(err, null, null);\n        });\n        return;\n    }\n    if (callback === undefined) {\n        // Stream mode\n        const requestStream = streamEvents(new stream_1.PassThrough());\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let responseStream;\n        requestStream.once('reading', () => {\n            if (responseStream) {\n                (0, stream_1.pipeline)(responseStream, requestStream, () => { });\n            }\n            else {\n                requestStream.once('response', () => {\n                    (0, stream_1.pipeline)(responseStream, requestStream, () => { });\n                });\n            }\n        });\n        options.compress = false;\n        teenyRequest.stats.requestStarting();\n        fetch(uri, options).then(res => {\n            teenyRequest.stats.requestFinished();\n            responseStream = res.body;\n            responseStream.on('error', (err) => {\n                requestStream.emit('error', err);\n            });\n            const response = fetchToRequestResponse(options, res);\n            requestStream.emit('response', response);\n        }, err => {\n            teenyRequest.stats.requestFinished();\n            requestStream.emit('error', err);\n        });\n        // fetch doesn't supply the raw HTTP stream, instead it\n        // returns a PassThrough piped from the HTTP response\n        // stream.\n        return requestStream;\n    }\n    // GET or POST with callback\n    teenyRequest.stats.requestStarting();\n    fetch(uri, options).then(res => {\n        teenyRequest.stats.requestFinished();\n        const header = res.headers.get('content-type');\n        const response = fetchToRequestResponse(options, res);\n        const body = response.body;\n        if (header === 'application/json' ||\n            header === 'application/json; charset=utf-8') {\n            if (response.statusCode === 204) {\n                // Probably a DELETE\n                callback(null, response, body);\n                return;\n            }\n            res.json().then(json => {\n                response.body = json;\n                callback(null, response, json);\n            }, err => {\n                callback(err, response, body);\n            });\n            return;\n        }\n        res.text().then(text => {\n            const response = fetchToRequestResponse(options, res);\n            response.body = text;\n            callback(null, response, text);\n        }, err => {\n            callback(err, response, body);\n        });\n    }, err => {\n        teenyRequest.stats.requestFinished();\n        callback(err, null, null);\n    });\n    return;\n}\nteenyRequest.defaults = (defaults) => {\n    return (reqOpts, callback) => {\n        const opts = { ...defaults, ...reqOpts };\n        if (callback === undefined) {\n            return teenyRequest(opts);\n        }\n        teenyRequest(opts, callback);\n    };\n};\n/**\n * Single instance of an interface for keeping track of things.\n */\nteenyRequest.stats = new TeenyStatistics_1.TeenyStatistics();\nteenyRequest.resetStats = () => {\n    teenyRequest.stats = new TeenyStatistics_1.TeenyStatistics(teenyRequest.stats.getOptions());\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGtFQUFlO0FBQzVDLDJCQUEyQixvZUFBb0IsU0FBUyxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNELG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsOEJBQThCLFNBQVMsb0JBQW9CLHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYW5pc2gtbGFuZ3VhZ2UtbGVhcm5pbmctYXBwLy4vbm9kZV9tb2R1bGVzL3RlZW55LXJlcXVlc3QvYnVpbGQvc3JjL2luZGV4LmpzP2Q5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXF1ZXN0RXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLnRlZW55UmVxdWVzdCA9IHRlZW55UmVxdWVzdDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGFnZW50c18xID0gcmVxdWlyZShcIi4vYWdlbnRzXCIpO1xuY29uc3QgVGVlbnlTdGF0aXN0aWNzXzEgPSByZXF1aXJlKFwiLi9UZWVueVN0YXRpc3RpY3NcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3Qgc3RyZWFtRXZlbnRzID0gcmVxdWlyZSgnc3RyZWFtLWV2ZW50cycpO1xuY29uc3QgZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG5jbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbn1cbmV4cG9ydHMuUmVxdWVzdEVycm9yID0gUmVxdWVzdEVycm9yO1xuLyoqXG4gKiBDb252ZXJ0IG9wdGlvbnMgZnJvbSBSZXF1ZXN0IHRvIEZldGNoIGZvcm1hdFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSByZXFPcHRzIFJlcXVlc3Qgb3B0aW9uc1xuICovXG5mdW5jdGlvbiByZXF1ZXN0VG9GZXRjaE9wdGlvbnMocmVxT3B0cykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogcmVxT3B0cy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIC4uLihyZXFPcHRzLnRpbWVvdXQgJiYgeyB0aW1lb3V0OiByZXFPcHRzLnRpbWVvdXQgfSksXG4gICAgICAgIC4uLih0eXBlb2YgcmVxT3B0cy5nemlwID09PSAnYm9vbGVhbicgJiYgeyBjb21wcmVzczogcmVxT3B0cy5nemlwIH0pLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiByZXFPcHRzLmpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIEFkZCBDb250ZW50LXR5cGU6IGFwcGxpY2F0aW9uL2pzb24gaGVhZGVyXG4gICAgICAgIHJlcU9wdHMuaGVhZGVycyA9IHJlcU9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKHJlcU9wdHMuaGVhZGVycyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSGVhZGVycykge1xuICAgICAgICAgICAgcmVxT3B0cy5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcU9wdHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IGJvZHkgdG8gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXFPcHRzLmpzb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihyZXFPcHRzLmJvZHkpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSByZXFPcHRzLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcU9wdHMuYm9keSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KHJlcU9wdHMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSByZXFPcHRzLmJvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlcU9wdHMuaGVhZGVycyBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuSGVhZGVycykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHJlcU9wdHMuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHJlcU9wdHMuaGVhZGVycztcbiAgICB9XG4gICAgbGV0IHVyaSA9IChyZXFPcHRzLnVyaSB8fFxuICAgICAgICByZXFPcHRzLnVybCk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHVyaSBvciB1cmwgaW4gcmVxT3B0cy4nKTtcbiAgICB9XG4gICAgaWYgKHJlcU9wdHMudXNlUXVlcnlzdHJpbmcgPT09IHRydWUgfHwgdHlwZW9mIHJlcU9wdHMucXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgIGNvbnN0IHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gcXMuc3RyaW5naWZ5KHJlcU9wdHMucXMpO1xuICAgICAgICB1cmkgPSB1cmkgKyAnPycgKyBwYXJhbXM7XG4gICAgfVxuICAgIG9wdGlvbnMuYWdlbnQgPSAoMCwgYWdlbnRzXzEuZ2V0QWdlbnQpKHVyaSwgcmVxT3B0cyk7XG4gICAgcmV0dXJuIHsgdXJpLCBvcHRpb25zIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSByZXNwb25zZSBmcm9tIGBmZXRjaGAgdG8gYHJlcXVlc3RgIGZvcm1hdC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gb3B0cyBUaGUgYHJlcXVlc3RgIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gcmVzIFRoZSBGZXRjaCByZXNwb25zZVxuICogQHJldHVybnMgQSBgcmVxdWVzdGAgcmVzcG9uc2Ugb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZldGNoVG9SZXF1ZXN0UmVzcG9uc2Uob3B0cywgcmVzKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHt9O1xuICAgIHJlcXVlc3QuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICAgIHJlcXVlc3QuaGVhZGVycyA9IChvcHRzLmhlYWRlcnMgfHwge30pO1xuICAgIHJlcXVlc3QuaHJlZiA9IHJlcy51cmw7XG4gICAgLy8gaGVhZGVycyBuZWVkIHRvIGJlIGNvbnZlcnRlZCBmcm9tIGEgbWFwIHRvIGFuIG9ialxuICAgIGNvbnN0IHJlc0hlYWRlcnMgPSB7fTtcbiAgICByZXMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiAocmVzSGVhZGVyc1trZXldID0gdmFsdWUpKTtcbiAgICBjb25zdCByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24ocmVzLmJvZHksIHtcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c1RleHQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGJvZHk6IHJlcy5ib2R5LFxuICAgICAgICBoZWFkZXJzOiByZXNIZWFkZXJzLFxuICAgICAgICB0b0pTT046ICgpID0+ICh7IGhlYWRlcnM6IHJlc0hlYWRlcnMgfSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuLyoqXG4gKiBDcmVhdGUgUE9TVCBib2R5IGZyb20gdHdvIHBhcnRzIGFzIG11bHRpcGFydC9yZWxhdGVkIGNvbnRlbnQtdHlwZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBib3VuZGFyeVxuICogQHBhcmFtIG11bHRpcGFydFxuICovXG5mdW5jdGlvbiBjcmVhdGVNdWx0aXBhcnRTdHJlYW0oYm91bmRhcnksIG11bHRpcGFydCkge1xuICAgIGNvbnN0IGZpbmFsZSA9IGAtLSR7Ym91bmRhcnl9LS1gO1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCgpO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBtdWx0aXBhcnQpIHtcbiAgICAgICAgY29uc3QgcHJlYW1ibGUgPSBgLS0ke2JvdW5kYXJ5fVxcclxcbkNvbnRlbnQtVHlwZTogJHtwYXJ0WydDb250ZW50LVR5cGUnXX1cXHJcXG5cXHJcXG5gO1xuICAgICAgICBzdHJlYW0ud3JpdGUocHJlYW1ibGUpO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnQuYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShwYXJ0LmJvZHkpO1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlKCdcXHJcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnQuYm9keS5waXBlKHN0cmVhbSwgeyBlbmQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcGFydC5ib2R5Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLndyaXRlKCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGUoZmluYWxlKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xufVxuZnVuY3Rpb24gdGVlbnlSZXF1ZXN0KHJlcU9wdHMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyB1cmksIG9wdGlvbnMgfSA9IHJlcXVlc3RUb0ZldGNoT3B0aW9ucyhyZXFPcHRzKTtcbiAgICBjb25zdCBtdWx0aXBhcnQgPSByZXFPcHRzLm11bHRpcGFydDtcbiAgICBpZiAocmVxT3B0cy5tdWx0aXBhcnQgJiYgbXVsdGlwYXJ0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgbXVsdGlwYXJ0IHVwbG9hZHMgdGhyb3VnaCBzdHJlYW1pbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwYXJ0IHdpdGhvdXQgY2FsbGJhY2sgaXMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gKDAsIGNyeXB0b18xLnJhbmRvbVVVSUQpKCk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPVxuICAgICAgICAgICAgYG11bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWA7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IGNyZWF0ZU11bHRpcGFydFN0cmVhbShib3VuZGFyeSwgbXVsdGlwYXJ0KTtcbiAgICAgICAgLy8gTXVsdGlwYXJ0IHVwbG9hZFxuICAgICAgICB0ZWVueVJlcXVlc3Quc3RhdHMucmVxdWVzdFN0YXJ0aW5nKCk7XG4gICAgICAgIGZldGNoKHVyaSwgb3B0aW9ucykudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgdGVlbnlSZXF1ZXN0LnN0YXRzLnJlcXVlc3RGaW5pc2hlZCgpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2hUb1JlcXVlc3RSZXNwb25zZShvcHRpb25zLCByZXMpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyID09PSAnYXBwbGljYXRpb24vanNvbicgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXIgPT09ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04Jykge1xuICAgICAgICAgICAgICAgIHJlcy5qc29uKCkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keSA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlLCBqc29uKTtcbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy50ZXh0KCkudGhlbih0ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gdGV4dDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSwgdGV4dCk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0ZWVueVJlcXVlc3Quc3RhdHMucmVxdWVzdEZpbmlzaGVkKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTdHJlYW0gbW9kZVxuICAgICAgICBjb25zdCByZXF1ZXN0U3RyZWFtID0gc3RyZWFtRXZlbnRzKG5ldyBzdHJlYW1fMS5QYXNzVGhyb3VnaCgpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHJlc3BvbnNlU3RyZWFtO1xuICAgICAgICByZXF1ZXN0U3RyZWFtLm9uY2UoJ3JlYWRpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlc3BvbnNlU3RyZWFtLCByZXF1ZXN0U3RyZWFtLCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0cmVhbS5vbmNlKCdyZXNwb25zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZXNwb25zZVN0cmVhbSwgcmVxdWVzdFN0cmVhbSwgKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgdGVlbnlSZXF1ZXN0LnN0YXRzLnJlcXVlc3RTdGFydGluZygpO1xuICAgICAgICBmZXRjaCh1cmksIG9wdGlvbnMpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIHRlZW55UmVxdWVzdC5zdGF0cy5yZXF1ZXN0RmluaXNoZWQoKTtcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtID0gcmVzLmJvZHk7XG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2hUb1JlcXVlc3RSZXNwb25zZShvcHRpb25zLCByZXMpO1xuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbS5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIHRlZW55UmVxdWVzdC5zdGF0cy5yZXF1ZXN0RmluaXNoZWQoKTtcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZmV0Y2ggZG9lc24ndCBzdXBwbHkgdGhlIHJhdyBIVFRQIHN0cmVhbSwgaW5zdGVhZCBpdFxuICAgICAgICAvLyByZXR1cm5zIGEgUGFzc1Rocm91Z2ggcGlwZWQgZnJvbSB0aGUgSFRUUCByZXNwb25zZVxuICAgICAgICAvLyBzdHJlYW0uXG4gICAgICAgIHJldHVybiByZXF1ZXN0U3RyZWFtO1xuICAgIH1cbiAgICAvLyBHRVQgb3IgUE9TVCB3aXRoIGNhbGxiYWNrXG4gICAgdGVlbnlSZXF1ZXN0LnN0YXRzLnJlcXVlc3RTdGFydGluZygpO1xuICAgIGZldGNoKHVyaSwgb3B0aW9ucykudGhlbihyZXMgPT4ge1xuICAgICAgICB0ZWVueVJlcXVlc3Quc3RhdHMucmVxdWVzdEZpbmlzaGVkKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2hUb1JlcXVlc3RSZXNwb25zZShvcHRpb25zLCByZXMpO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgaWYgKGhlYWRlciA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nIHx8XG4gICAgICAgICAgICBoZWFkZXIgPT09ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04Jykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwNCkge1xuICAgICAgICAgICAgICAgIC8vIFByb2JhYmx5IGEgREVMRVRFXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UsIGJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5qc29uKCkudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5ID0ganNvbjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZSwganNvbik7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBmZXRjaFRvUmVxdWVzdFJlc3BvbnNlKG9wdGlvbnMsIHJlcyk7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gdGV4dDtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlLCB0ZXh0KTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIGJvZHkpO1xuICAgICAgICB9KTtcbiAgICB9LCBlcnIgPT4ge1xuICAgICAgICB0ZWVueVJlcXVlc3Quc3RhdHMucmVxdWVzdEZpbmlzaGVkKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xufVxudGVlbnlSZXF1ZXN0LmRlZmF1bHRzID0gKGRlZmF1bHRzKSA9PiB7XG4gICAgcmV0dXJuIChyZXFPcHRzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCBvcHRzID0geyAuLi5kZWZhdWx0cywgLi4ucmVxT3B0cyB9O1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRlZW55UmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICB0ZWVueVJlcXVlc3Qob3B0cywgY2FsbGJhY2spO1xuICAgIH07XG59O1xuLyoqXG4gKiBTaW5nbGUgaW5zdGFuY2Ugb2YgYW4gaW50ZXJmYWNlIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoaW5ncy5cbiAqL1xudGVlbnlSZXF1ZXN0LnN0YXRzID0gbmV3IFRlZW55U3RhdGlzdGljc18xLlRlZW55U3RhdGlzdGljcygpO1xudGVlbnlSZXF1ZXN0LnJlc2V0U3RhdHMgPSAoKSA9PiB7XG4gICAgdGVlbnlSZXF1ZXN0LnN0YXRzID0gbmV3IFRlZW55U3RhdGlzdGljc18xLlRlZW55U3RhdGlzdGljcyh0ZWVueVJlcXVlc3Quc3RhdHMuZ2V0T3B0aW9ucygpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/@tootallnate/once/dist/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/@tootallnate/once/dist/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction once(emitter, name, { signal } = {}) {\n    return new Promise((resolve, reject) => {\n        function cleanup() {\n            signal === null || signal === void 0 ? void 0 : signal.removeEventListener('abort', cleanup);\n            emitter.removeListener(name, onEvent);\n            emitter.removeListener('error', onError);\n        }\n        function onEvent(...args) {\n            cleanup();\n            resolve(args);\n        }\n        function onError(err) {\n            cleanup();\n            reject(err);\n        }\n        signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', cleanup);\n        emitter.on(name, onEvent);\n        emitter.on('error', onError);\n    });\n}\nexports[\"default\"] = once;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvQHRvb3RhbGxuYXRlL29uY2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsU0FBUyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhbmlzaC1sYW5ndWFnZS1sZWFybmluZy1hcHAvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvQHRvb3RhbGxuYXRlL29uY2UvZGlzdC9pbmRleC5qcz9jMDM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lLCB7IHNpZ25hbCB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgY2xlYW51cCk7XG4gICAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIG9uRXZlbnQpO1xuICAgICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkV2ZW50KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbCA9PT0gbnVsbCB8fCBzaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGNsZWFudXApO1xuICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIG9uRXZlbnQpO1xuICAgICAgICBlbWl0dGVyLm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gb25jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/@tootallnate/once/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/agent-base/dist/src/index.js ***!
  \******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst promisify_1 = __importDefault(__webpack_require__(/*! ./promisify */ \"(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/promisify.js\"));\nconst debug = debug_1.default('agent-base');\nfunction isAgent(v) {\n    return Boolean(v) && typeof v.addRequest === 'function';\n}\nfunction isSecureEndpoint() {\n    const { stack } = new Error();\n    if (typeof stack !== 'string')\n        return false;\n    return stack.split('\\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);\n}\nfunction createAgent(callback, opts) {\n    return new createAgent.Agent(callback, opts);\n}\n(function (createAgent) {\n    /**\n     * Base `http.Agent` implementation.\n     * No pooling/keep-alive is implemented by default.\n     *\n     * @param {Function} callback\n     * @api public\n     */\n    class Agent extends events_1.EventEmitter {\n        constructor(callback, _opts) {\n            super();\n            let opts = _opts;\n            if (typeof callback === 'function') {\n                this.callback = callback;\n            }\n            else if (callback) {\n                opts = callback;\n            }\n            // Timeout for the socket to be returned from the callback\n            this.timeout = null;\n            if (opts && typeof opts.timeout === 'number') {\n                this.timeout = opts.timeout;\n            }\n            // These aren't actually used by `agent-base`, but are required\n            // for the TypeScript definition files in `@types/node` :/\n            this.maxFreeSockets = 1;\n            this.maxSockets = 1;\n            this.maxTotalSockets = Infinity;\n            this.sockets = {};\n            this.freeSockets = {};\n            this.requests = {};\n            this.options = {};\n        }\n        get defaultPort() {\n            if (typeof this.explicitDefaultPort === 'number') {\n                return this.explicitDefaultPort;\n            }\n            return isSecureEndpoint() ? 443 : 80;\n        }\n        set defaultPort(v) {\n            this.explicitDefaultPort = v;\n        }\n        get protocol() {\n            if (typeof this.explicitProtocol === 'string') {\n                return this.explicitProtocol;\n            }\n            return isSecureEndpoint() ? 'https:' : 'http:';\n        }\n        set protocol(v) {\n            this.explicitProtocol = v;\n        }\n        callback(req, opts, fn) {\n            throw new Error('\"agent-base\" has no default implementation, you must subclass and override `callback()`');\n        }\n        /**\n         * Called by node-core's \"_http_client.js\" module when creating\n         * a new HTTP request with this Agent instance.\n         *\n         * @api public\n         */\n        addRequest(req, _opts) {\n            const opts = Object.assign({}, _opts);\n            if (typeof opts.secureEndpoint !== 'boolean') {\n                opts.secureEndpoint = isSecureEndpoint();\n            }\n            if (opts.host == null) {\n                opts.host = 'localhost';\n            }\n            if (opts.port == null) {\n                opts.port = opts.secureEndpoint ? 443 : 80;\n            }\n            if (opts.protocol == null) {\n                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';\n            }\n            if (opts.host && opts.path) {\n                // If both a `host` and `path` are specified then it's most\n                // likely the result of a `url.parse()` call... we need to\n                // remove the `path` portion so that `net.connect()` doesn't\n                // attempt to open that as a unix socket file.\n                delete opts.path;\n            }\n            delete opts.agent;\n            delete opts.hostname;\n            delete opts._defaultAgent;\n            delete opts.defaultPort;\n            delete opts.createConnection;\n            // Hint to use \"Connection: close\"\n            // XXX: non-documented `http` module API :(\n            req._last = true;\n            req.shouldKeepAlive = false;\n            let timedOut = false;\n            let timeoutId = null;\n            const timeoutMs = opts.timeout || this.timeout;\n            const onerror = (err) => {\n                if (req._hadError)\n                    return;\n                req.emit('error', err);\n                // For Safety. Some additional errors might fire later on\n                // and we need to make sure we don't double-fire the error event.\n                req._hadError = true;\n            };\n            const ontimeout = () => {\n                timeoutId = null;\n                timedOut = true;\n                const err = new Error(`A \"socket\" was not created for HTTP request before ${timeoutMs}ms`);\n                err.code = 'ETIMEOUT';\n                onerror(err);\n            };\n            const callbackError = (err) => {\n                if (timedOut)\n                    return;\n                if (timeoutId !== null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                onerror(err);\n            };\n            const onsocket = (socket) => {\n                if (timedOut)\n                    return;\n                if (timeoutId != null) {\n                    clearTimeout(timeoutId);\n                    timeoutId = null;\n                }\n                if (isAgent(socket)) {\n                    // `socket` is actually an `http.Agent` instance, so\n                    // relinquish responsibility for this `req` to the Agent\n                    // from here on\n                    debug('Callback returned another Agent instance %o', socket.constructor.name);\n                    socket.addRequest(req, opts);\n                    return;\n                }\n                if (socket) {\n                    socket.once('free', () => {\n                        this.freeSocket(socket, opts);\n                    });\n                    req.onSocket(socket);\n                    return;\n                }\n                const err = new Error(`no Duplex stream was returned to agent-base for \\`${req.method} ${req.path}\\``);\n                onerror(err);\n            };\n            if (typeof this.callback !== 'function') {\n                onerror(new Error('`callback` is not defined'));\n                return;\n            }\n            if (!this.promisifiedCallback) {\n                if (this.callback.length >= 3) {\n                    debug('Converting legacy callback function to promise');\n                    this.promisifiedCallback = promisify_1.default(this.callback);\n                }\n                else {\n                    this.promisifiedCallback = this.callback;\n                }\n            }\n            if (typeof timeoutMs === 'number' && timeoutMs > 0) {\n                timeoutId = setTimeout(ontimeout, timeoutMs);\n            }\n            if ('port' in opts && typeof opts.port !== 'number') {\n                opts.port = Number(opts.port);\n            }\n            try {\n                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);\n                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);\n            }\n            catch (err) {\n                Promise.reject(err).catch(callbackError);\n            }\n        }\n        freeSocket(socket, opts) {\n            debug('Freeing socket %o %o', socket.constructor.name, opts);\n            socket.destroy();\n        }\n        destroy() {\n            debug('Destroying agent %o', this.constructor.name);\n        }\n    }\n    createAgent.Agent = Agent;\n    // So that `instanceof` works correctly\n    createAgent.prototype = createAgent.Agent.prototype;\n})(createAgent || (createAgent = {}));\nmodule.exports = createAgent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0Msb0NBQW9DLG1CQUFPLENBQUMscUdBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixZQUFZLEVBQUUsU0FBUztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZLEVBQUUsU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYW5pc2gtbGFuZ3VhZ2UtbGVhcm5pbmctYXBwLy4vbm9kZV9tb2R1bGVzL3RlZW55LXJlcXVlc3Qvbm9kZV9tb2R1bGVzL2FnZW50LWJhc2UvZGlzdC9zcmMvaW5kZXguanM/Y2UwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHByb21pc2lmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Byb21pc2lmeVwiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnYWdlbnQtYmFzZScpO1xuZnVuY3Rpb24gaXNBZ2VudCh2KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odikgJiYgdHlwZW9mIHYuYWRkUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzU2VjdXJlRW5kcG9pbnQoKSB7XG4gICAgY29uc3QgeyBzdGFjayB9ID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKHR5cGVvZiBzdGFjayAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpLnNvbWUobCA9PiBsLmluZGV4T2YoJyhodHRwcy5qczonKSAhPT0gLTEgfHwgbC5pbmRleE9mKCdub2RlOmh0dHBzOicpICE9PSAtMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBZ2VudChjYWxsYmFjaywgb3B0cykge1xuICAgIHJldHVybiBuZXcgY3JlYXRlQWdlbnQuQWdlbnQoY2FsbGJhY2ssIG9wdHMpO1xufVxuKGZ1bmN0aW9uIChjcmVhdGVBZ2VudCkge1xuICAgIC8qKlxuICAgICAqIEJhc2UgYGh0dHAuQWdlbnRgIGltcGxlbWVudGF0aW9uLlxuICAgICAqIE5vIHBvb2xpbmcva2VlcC1hbGl2ZSBpcyBpbXBsZW1lbnRlZCBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIEFnZW50IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIF9vcHRzKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgbGV0IG9wdHMgPSBfb3B0cztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdHMgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRpbWVvdXQgZm9yIHRoZSBzb2NrZXQgdG8gYmUgcmV0dXJuZWQgZnJvbSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZW4ndCBhY3R1YWxseSB1c2VkIGJ5IGBhZ2VudC1iYXNlYCwgYnV0IGFyZSByZXF1aXJlZFxuICAgICAgICAgICAgLy8gZm9yIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gZmlsZXMgaW4gYEB0eXBlcy9ub2RlYCA6L1xuICAgICAgICAgICAgdGhpcy5tYXhGcmVlU29ja2V0cyA9IDE7XG4gICAgICAgICAgICB0aGlzLm1heFNvY2tldHMgPSAxO1xuICAgICAgICAgICAgdGhpcy5tYXhUb3RhbFNvY2tldHMgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mcmVlU29ja2V0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRlZmF1bHRQb3J0KCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV4cGxpY2l0RGVmYXVsdFBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXREZWZhdWx0UG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NlY3VyZUVuZHBvaW50KCkgPyA0NDMgOiA4MDtcbiAgICAgICAgfVxuICAgICAgICBzZXQgZGVmYXVsdFBvcnQodikge1xuICAgICAgICAgICAgdGhpcy5leHBsaWNpdERlZmF1bHRQb3J0ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcHJvdG9jb2woKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXhwbGljaXRQcm90b2NvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdFByb3RvY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2VjdXJlRW5kcG9pbnQoKSA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgICAgICAgfVxuICAgICAgICBzZXQgcHJvdG9jb2wodikge1xuICAgICAgICAgICAgdGhpcy5leHBsaWNpdFByb3RvY29sID0gdjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhyZXEsIG9wdHMsIGZuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiYWdlbnQtYmFzZVwiIGhhcyBubyBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCB5b3UgbXVzdCBzdWJjbGFzcyBhbmQgb3ZlcnJpZGUgYGNhbGxiYWNrKClgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBieSBub2RlLWNvcmUncyBcIl9odHRwX2NsaWVudC5qc1wiIG1vZHVsZSB3aGVuIGNyZWF0aW5nXG4gICAgICAgICAqIGEgbmV3IEhUVFAgcmVxdWVzdCB3aXRoIHRoaXMgQWdlbnQgaW5zdGFuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhcGkgcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZXF1ZXN0KHJlcSwgX29wdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBfb3B0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuc2VjdXJlRW5kcG9pbnQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIG9wdHMuc2VjdXJlRW5kcG9pbnQgPSBpc1NlY3VyZUVuZHBvaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5ob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhvc3QgPSAnbG9jYWxob3N0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnBvcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdHMucG9ydCA9IG9wdHMuc2VjdXJlRW5kcG9pbnQgPyA0NDMgOiA4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnByb3RvY29sID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnByb3RvY29sID0gb3B0cy5zZWN1cmVFbmRwb2ludCA/ICdodHRwczonIDogJ2h0dHA6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmhvc3QgJiYgb3B0cy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYm90aCBhIGBob3N0YCBhbmQgYHBhdGhgIGFyZSBzcGVjaWZpZWQgdGhlbiBpdCdzIG1vc3RcbiAgICAgICAgICAgICAgICAvLyBsaWtlbHkgdGhlIHJlc3VsdCBvZiBhIGB1cmwucGFyc2UoKWAgY2FsbC4uLiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBgcGF0aGAgcG9ydGlvbiBzbyB0aGF0IGBuZXQuY29ubmVjdCgpYCBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBvcGVuIHRoYXQgYXMgYSB1bml4IHNvY2tldCBmaWxlLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgb3B0cy5hZ2VudDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmhvc3RuYW1lO1xuICAgICAgICAgICAgZGVsZXRlIG9wdHMuX2RlZmF1bHRBZ2VudDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLmRlZmF1bHRQb3J0O1xuICAgICAgICAgICAgZGVsZXRlIG9wdHMuY3JlYXRlQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIC8vIEhpbnQgdG8gdXNlIFwiQ29ubmVjdGlvbjogY2xvc2VcIlxuICAgICAgICAgICAgLy8gWFhYOiBub24tZG9jdW1lbnRlZCBgaHR0cGAgbW9kdWxlIEFQSSA6KFxuICAgICAgICAgICAgcmVxLl9sYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcS5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0TXMgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0O1xuICAgICAgICAgICAgY29uc3Qgb25lcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLl9oYWRFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHJlcS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgLy8gRm9yIFNhZmV0eS4gU29tZSBhZGRpdGlvbmFsIGVycm9ycyBtaWdodCBmaXJlIGxhdGVyIG9uXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGRvdWJsZS1maXJlIHRoZSBlcnJvciBldmVudC5cbiAgICAgICAgICAgICAgICByZXEuX2hhZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBIFwic29ja2V0XCIgd2FzIG5vdCBjcmVhdGVkIGZvciBIVFRQIHJlcXVlc3QgYmVmb3JlICR7dGltZW91dE1zfW1zYCk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSAnRVRJTUVPVVQnO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja0Vycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lZE91dClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbnNvY2tldCA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltZWRPdXQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0FnZW50KHNvY2tldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNvY2tldGAgaXMgYWN0dWFsbHkgYW4gYGh0dHAuQWdlbnRgIGluc3RhbmNlLCBzb1xuICAgICAgICAgICAgICAgICAgICAvLyByZWxpbnF1aXNoIHJlc3BvbnNpYmlsaXR5IGZvciB0aGlzIGByZXFgIHRvIHRoZSBBZ2VudFxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIGhlcmUgb25cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ0NhbGxiYWNrIHJldHVybmVkIGFub3RoZXIgQWdlbnQgaW5zdGFuY2UgJW8nLCBzb2NrZXQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5hZGRSZXF1ZXN0KHJlcSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgnZnJlZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZVNvY2tldChzb2NrZXQsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uU29ja2V0KHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBubyBEdXBsZXggc3RyZWFtIHdhcyByZXR1cm5lZCB0byBhZ2VudC1iYXNlIGZvciBcXGAke3JlcS5tZXRob2R9ICR7cmVxLnBhdGh9XFxgYCk7XG4gICAgICAgICAgICAgICAgb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9uZXJyb3IobmV3IEVycm9yKCdgY2FsbGJhY2tgIGlzIG5vdCBkZWZpbmVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9taXNpZmllZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2subGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ0NvbnZlcnRpbmcgbGVnYWN5IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHByb21pc2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9taXNpZmllZENhbGxiYWNrID0gcHJvbWlzaWZ5XzEuZGVmYXVsdCh0aGlzLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzaWZpZWRDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0TXMgPT09ICdudW1iZXInICYmIHRpbWVvdXRNcyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9udGltZW91dCwgdGltZW91dE1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncG9ydCcgaW4gb3B0cyAmJiB0eXBlb2Ygb3B0cy5wb3J0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG9wdHMucG9ydCA9IE51bWJlcihvcHRzLnBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnUmVzb2x2aW5nIHNvY2tldCBmb3IgJW8gcmVxdWVzdDogJW8nLCBvcHRzLnByb3RvY29sLCBgJHtyZXEubWV0aG9kfSAke3JlcS5wYXRofWApO1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0aGlzLnByb21pc2lmaWVkQ2FsbGJhY2socmVxLCBvcHRzKSkudGhlbihvbnNvY2tldCwgY2FsbGJhY2tFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyKS5jYXRjaChjYWxsYmFja0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmcmVlU29ja2V0KHNvY2tldCwgb3B0cykge1xuICAgICAgICAgICAgZGVidWcoJ0ZyZWVpbmcgc29ja2V0ICVvICVvJywgc29ja2V0LmNvbnN0cnVjdG9yLm5hbWUsIG9wdHMpO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVidWcoJ0Rlc3Ryb3lpbmcgYWdlbnQgJW8nLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUFnZW50LkFnZW50ID0gQWdlbnQ7XG4gICAgLy8gU28gdGhhdCBgaW5zdGFuY2VvZmAgd29ya3MgY29ycmVjdGx5XG4gICAgY3JlYXRlQWdlbnQucHJvdG90eXBlID0gY3JlYXRlQWdlbnQuQWdlbnQucHJvdG90eXBlO1xufSkoY3JlYXRlQWdlbnQgfHwgKGNyZWF0ZUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/promisify.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/agent-base/dist/src/promisify.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction promisify(fn) {\n    return function (req, opts) {\n        return new Promise((resolve, reject) => {\n            fn.call(this, req, opts, (err, rtn) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(rtn);\n                }\n            });\n        });\n    };\n}\nexports[\"default\"] = promisify;\n//# sourceMappingURL=promisify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L3NyYy9wcm9taXNpZnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhbmlzaC1sYW5ndWFnZS1sZWFybmluZy1hcHAvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvYWdlbnQtYmFzZS9kaXN0L3NyYy9wcm9taXNpZnkuanM/ODI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHByb21pc2lmeShmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVxLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIHJlcSwgb3B0cywgKGVyciwgcnRuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocnRuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByb21pc2lmeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2lmeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/promisify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/agent.js":
/*!********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/http-proxy-agent/dist/agent.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ \"(rsc)/./node_modules/teeny-request/node_modules/@tootallnate/once/dist/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/index.js\");\nconst debug = (0, debug_1.default)('http-proxy-agent');\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\n/**\n * The `HttpProxyAgent` implements an HTTP Agent subclass that connects\n * to the specified \"HTTP proxy server\" in order to proxy HTTP requests.\n *\n * @api public\n */\nclass HttpProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('Creating new HttpProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            const parsed = url_1.default.parse(req.path);\n            if (!parsed.protocol) {\n                parsed.protocol = 'http:';\n            }\n            if (!parsed.hostname) {\n                parsed.hostname = opts.hostname || opts.host || null;\n            }\n            if (parsed.port == null && typeof opts.port) {\n                parsed.port = String(opts.port);\n            }\n            if (parsed.port === '80') {\n                // if port is 80, then we can remove the port so that the\n                // \":80\" portion is not on the produced URL\n                parsed.port = '';\n            }\n            // Change the `http.ClientRequest` instance's \"path\" field\n            // to the absolute path of the URL that will be requested.\n            req.path = url_1.default.format(parsed);\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                req.setHeader('Proxy-Authorization', `Basic ${Buffer.from(proxy.auth).toString('base64')}`);\n            }\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            // At this point, the http ClientRequest's internal `_header` field\n            // might have already been set. If this is the case then we'll need\n            // to re-generate the string since we just changed the `req.path`.\n            if (req._header) {\n                let first;\n                let endOfHeaders;\n                debug('Regenerating stored HTTP header string for request');\n                req._header = null;\n                req._implicitHeader();\n                if (req.output && req.output.length > 0) {\n                    // Node < 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.output[0];\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.output[0] = req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.output);\n                }\n                else if (req.outputData && req.outputData.length > 0) {\n                    // Node >= 12\n                    debug('Patching connection write() output buffer with updated header');\n                    first = req.outputData[0].data;\n                    endOfHeaders = first.indexOf('\\r\\n\\r\\n') + 4;\n                    req.outputData[0].data =\n                        req._header + first.substring(endOfHeaders);\n                    debug('Output buffer: %o', req.outputData[0].data);\n                }\n            }\n            // Wait for the socket's `connect` event, so that this `callback()`\n            // function throws instead of the `http` request machinery. This is\n            // important for i.e. `PacProxyAgent` which determines a failed proxy\n            // connection via the `callback()` function throwing.\n            yield (0, once_1.default)(socket, 'connect');\n            return socket;\n        });\n    }\n}\nexports[\"default\"] = HttpProxyAgent;\n//# sourceMappingURL=agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1wcm94eS1hZ2VudC9kaXN0L2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixtQkFBTyxDQUFDLGdCQUFLO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdCQUFLO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLGdCQUFLO0FBQzNDLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDBHQUFtQjtBQUMxRCxxQkFBcUIsbUJBQU8sQ0FBQyxnR0FBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQ0FBMkM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYW5pc2gtbGFuZ3VhZ2UtbGVhcm5pbmctYXBwLy4vbm9kZV9tb2R1bGVzL3RlZW55LXJlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcz9jZDNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHRsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybFwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBvbmNlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkB0b290YWxsbmF0ZS9vbmNlXCIpKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnaHR0cC1wcm94eS1hZ2VudCcpO1xuZnVuY3Rpb24gaXNIVFRQUyhwcm90b2NvbCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnID8gL15odHRwczo/JC9pLnRlc3QocHJvdG9jb2wpIDogZmFsc2U7XG59XG4vKipcbiAqIFRoZSBgSHR0cFByb3h5QWdlbnRgIGltcGxlbWVudHMgYW4gSFRUUCBBZ2VudCBzdWJjbGFzcyB0aGF0IGNvbm5lY3RzXG4gKiB0byB0aGUgc3BlY2lmaWVkIFwiSFRUUCBwcm94eSBzZXJ2ZXJcIiBpbiBvcmRlciB0byBwcm94eSBIVFRQIHJlcXVlc3RzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmNsYXNzIEh0dHBQcm94eUFnZW50IGV4dGVuZHMgYWdlbnRfYmFzZV8xLkFnZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0cykge1xuICAgICAgICBsZXQgb3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBfb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmxfMS5kZWZhdWx0LnBhcnNlKF9vcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSBfb3B0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW4gSFRUUChTKSBwcm94eSBzZXJ2ZXIgYGhvc3RgIGFuZCBgcG9ydGAgbXVzdCBiZSBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ0NyZWF0aW5nIG5ldyBIdHRwUHJveHlBZ2VudCBpbnN0YW5jZTogJW8nLCBvcHRzKTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyk7XG4gICAgICAgIC8vIElmIGB0cnVlYCwgdGhlbiBjb25uZWN0IHRvIHRoZSBwcm94eSBzZXJ2ZXIgb3ZlciBUTFMuXG4gICAgICAgIC8vIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgIHRoaXMuc2VjdXJlUHJveHkgPSBvcHRzLnNlY3VyZVByb3h5IHx8IGlzSFRUUFMocHJveHkucHJvdG9jb2wpO1xuICAgICAgICAvLyBQcmVmZXIgYGhvc3RuYW1lYCBvdmVyIGBob3N0YCwgYW5kIHNldCB0aGUgYHBvcnRgIGlmIG5lZWRlZC5cbiAgICAgICAgcHJveHkuaG9zdCA9IHByb3h5Lmhvc3RuYW1lIHx8IHByb3h5Lmhvc3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcHJveHkucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSBwYXJzZUludChwcm94eS5wb3J0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm94eS5wb3J0ICYmIHByb3h5Lmhvc3QpIHtcbiAgICAgICAgICAgIHByb3h5LnBvcnQgPSB0aGlzLnNlY3VyZVByb3h5ID8gNDQzIDogODA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3h5Lmhvc3QgJiYgcHJveHkucGF0aCkge1xuICAgICAgICAgICAgLy8gSWYgYm90aCBhIGBob3N0YCBhbmQgYHBhdGhgIGFyZSBzcGVjaWZpZWQgdGhlbiBpdCdzIG1vc3QgbGlrZWx5XG4gICAgICAgICAgICAvLyB0aGUgcmVzdWx0IG9mIGEgYHVybC5wYXJzZSgpYCBjYWxsLi4uIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gYHBhdGhgIHBvcnRpb24gc28gdGhhdCBgbmV0LmNvbm5lY3QoKWAgZG9lc24ndCBhdHRlbXB0IHRvIG9wZW5cbiAgICAgICAgICAgIC8vIHRoYXQgYXMgYSBVbml4IHNvY2tldCBmaWxlLlxuICAgICAgICAgICAgZGVsZXRlIHByb3h5LnBhdGg7XG4gICAgICAgICAgICBkZWxldGUgcHJveHkucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbm9kZS1jb3JlIEhUVFAgY2xpZW50IGxpYnJhcnkgaXMgY3JlYXRpbmcgYVxuICAgICAqIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm94eSwgc2VjdXJlUHJveHkgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB1cmxfMS5kZWZhdWx0LnBhcnNlKHJlcS5wYXRoKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWQucG9ydCA9PSBudWxsICYmIHR5cGVvZiBvcHRzLnBvcnQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucG9ydCA9IFN0cmluZyhvcHRzLnBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZC5wb3J0ID09PSAnODAnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcG9ydCBpcyA4MCwgdGhlbiB3ZSBjYW4gcmVtb3ZlIHRoZSBwb3J0IHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gXCI6ODBcIiBwb3J0aW9uIGlzIG5vdCBvbiB0aGUgcHJvZHVjZWQgVVJMXG4gICAgICAgICAgICAgICAgcGFyc2VkLnBvcnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgYGh0dHAuQ2xpZW50UmVxdWVzdGAgaW5zdGFuY2UncyBcInBhdGhcIiBmaWVsZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkLlxuICAgICAgICAgICAgcmVxLnBhdGggPSB1cmxfMS5kZWZhdWx0LmZvcm1hdChwYXJzZWQpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChwcm94eS5hdXRoKSB7XG4gICAgICAgICAgICAgICAgcmVxLnNldEhlYWRlcignUHJveHktQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke0J1ZmZlci5mcm9tKHByb3h5LmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIuXG4gICAgICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICAgICAgaWYgKHNlY3VyZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gdGxzXzEuZGVmYXVsdC5jb25uZWN0KHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvJywgcHJveHkpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldF8xLmRlZmF1bHQuY29ubmVjdChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgaHR0cCBDbGllbnRSZXF1ZXN0J3MgaW50ZXJuYWwgYF9oZWFkZXJgIGZpZWxkXG4gICAgICAgICAgICAvLyBtaWdodCBoYXZlIGFscmVhZHkgYmVlbiBzZXQuIElmIHRoaXMgaXMgdGhlIGNhc2UgdGhlbiB3ZSdsbCBuZWVkXG4gICAgICAgICAgICAvLyB0byByZS1nZW5lcmF0ZSB0aGUgc3RyaW5nIHNpbmNlIHdlIGp1c3QgY2hhbmdlZCB0aGUgYHJlcS5wYXRoYC5cbiAgICAgICAgICAgIGlmIChyZXEuX2hlYWRlcikge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdDtcbiAgICAgICAgICAgICAgICBsZXQgZW5kT2ZIZWFkZXJzO1xuICAgICAgICAgICAgICAgIGRlYnVnKCdSZWdlbmVyYXRpbmcgc3RvcmVkIEhUVFAgaGVhZGVyIHN0cmluZyBmb3IgcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHJlcS5faGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXEuX2ltcGxpY2l0SGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5vdXRwdXQgJiYgcmVxLm91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUgPCAxMlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnUGF0Y2hpbmcgY29ubmVjdGlvbiB3cml0ZSgpIG91dHB1dCBidWZmZXIgd2l0aCB1cGRhdGVkIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHJlcS5vdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgICAgIGVuZE9mSGVhZGVycyA9IGZpcnN0LmluZGV4T2YoJ1xcclxcblxcclxcbicpICsgNDtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm91dHB1dFswXSA9IHJlcS5faGVhZGVyICsgZmlyc3Quc3Vic3RyaW5nKGVuZE9mSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdPdXRwdXQgYnVmZmVyOiAlbycsIHJlcS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXEub3V0cHV0RGF0YSAmJiByZXEub3V0cHV0RGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUgPj0gMTJcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1BhdGNoaW5nIGNvbm5lY3Rpb24gd3JpdGUoKSBvdXRwdXQgYnVmZmVyIHdpdGggdXBkYXRlZCBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSByZXEub3V0cHV0RGF0YVswXS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZkhlYWRlcnMgPSBmaXJzdC5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKSArIDQ7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vdXRwdXREYXRhWzBdLmRhdGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLl9oZWFkZXIgKyBmaXJzdC5zdWJzdHJpbmcoZW5kT2ZIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ091dHB1dCBidWZmZXI6ICVvJywgcmVxLm91dHB1dERhdGFbMF0uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHNvY2tldCdzIGBjb25uZWN0YCBldmVudCwgc28gdGhhdCB0aGlzIGBjYWxsYmFjaygpYFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhyb3dzIGluc3RlYWQgb2YgdGhlIGBodHRwYCByZXF1ZXN0IG1hY2hpbmVyeS4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBpLmUuIGBQYWNQcm94eUFnZW50YCB3aGljaCBkZXRlcm1pbmVzIGEgZmFpbGVkIHByb3h5XG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIHZpYSB0aGUgYGNhbGxiYWNrKClgIGZ1bmN0aW9uIHRocm93aW5nLlxuICAgICAgICAgICAgeWllbGQgKDAsIG9uY2VfMS5kZWZhdWx0KShzb2NrZXQsICdjb25uZWN0Jyk7XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/http-proxy-agent/dist/index.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/agent.js\"));\nfunction createHttpProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpProxyAgent) {\n    createHttpProxyAgent.HttpProxyAgent = agent_1.default;\n    createHttpProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpProxyAgent || (createHttpProxyAgent = {}));\nmodule.exports = createHttpProxyAgent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxnQ0FBZ0MsbUJBQU8sQ0FBQywrRkFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhbmlzaC1sYW5ndWFnZS1sZWFybmluZy1hcHAvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzPzk3NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBhZ2VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FnZW50XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBQcm94eUFnZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdChvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlSHR0cFByb3h5QWdlbnQpIHtcbiAgICBjcmVhdGVIdHRwUHJveHlBZ2VudC5IdHRwUHJveHlBZ2VudCA9IGFnZW50XzEuZGVmYXVsdDtcbiAgICBjcmVhdGVIdHRwUHJveHlBZ2VudC5wcm90b3R5cGUgPSBhZ2VudF8xLmRlZmF1bHQucHJvdG90eXBlO1xufSkoY3JlYXRlSHR0cFByb3h5QWdlbnQgfHwgKGNyZWF0ZUh0dHBQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHR0cFByb3h5QWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/http-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/agent.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/https-proxy-agent/dist/agent.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/teeny-request/node_modules/agent-base/dist/src/index.js\");\nconst parse_proxy_response_1 = __importDefault(__webpack_require__(/*! ./parse-proxy-response */ \"(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/parse-proxy-response.js\"));\nconst debug = debug_1.default('https-proxy-agent:agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n *\n * @api public\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n    constructor(_opts) {\n        let opts;\n        if (typeof _opts === 'string') {\n            opts = url_1.default.parse(_opts);\n        }\n        else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n        }\n        debug('creating new HttpsProxyAgent instance: %o', opts);\n        super(opts);\n        const proxy = Object.assign({}, opts);\n        // If `true`, then connect to the proxy server over TLS.\n        // Defaults to `false`.\n        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);\n        // Prefer `hostname` over `host`, and set the `port` if needed.\n        proxy.host = proxy.hostname || proxy.host;\n        if (typeof proxy.port === 'string') {\n            proxy.port = parseInt(proxy.port, 10);\n        }\n        if (!proxy.port && proxy.host) {\n            proxy.port = this.secureProxy ? 443 : 80;\n        }\n        // ALPN is supported by Node.js >= v5.\n        // attempt to negotiate http/1.1 for proxy servers that support http/2\n        if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n            proxy.ALPNProtocols = ['http 1.1'];\n        }\n        if (proxy.host && proxy.path) {\n            // If both a `host` and `path` are specified then it's most likely\n            // the result of a `url.parse()` call... we need to remove the\n            // `path` portion so that `net.connect()` doesn't attempt to open\n            // that as a Unix socket file.\n            delete proxy.path;\n            delete proxy.pathname;\n        }\n        this.proxy = proxy;\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a\n     * new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { proxy, secureProxy } = this;\n            // Create a socket connection to the proxy server.\n            let socket;\n            if (secureProxy) {\n                debug('Creating `tls.Socket`: %o', proxy);\n                socket = tls_1.default.connect(proxy);\n            }\n            else {\n                debug('Creating `net.Socket`: %o', proxy);\n                socket = net_1.default.connect(proxy);\n            }\n            const headers = Object.assign({}, proxy.headers);\n            const hostname = `${opts.host}:${opts.port}`;\n            let payload = `CONNECT ${hostname} HTTP/1.1\\r\\n`;\n            // Inject the `Proxy-Authorization` header if necessary.\n            if (proxy.auth) {\n                headers['Proxy-Authorization'] = `Basic ${Buffer.from(proxy.auth).toString('base64')}`;\n            }\n            // The `Host` header should only include the port\n            // number when it is not the default port.\n            let { host, port, secureEndpoint } = opts;\n            if (!isDefaultPort(port, secureEndpoint)) {\n                host += `:${port}`;\n            }\n            headers.Host = host;\n            headers.Connection = 'close';\n            for (const name of Object.keys(headers)) {\n                payload += `${name}: ${headers[name]}\\r\\n`;\n            }\n            const proxyResponsePromise = parse_proxy_response_1.default(socket);\n            socket.write(`${payload}\\r\\n`);\n            const { statusCode, buffered } = yield proxyResponsePromise;\n            if (statusCode === 200) {\n                req.once('socket', resume);\n                if (opts.secureEndpoint) {\n                    // The proxy is connecting to a TLS server, so upgrade\n                    // this socket connection to a TLS connection.\n                    debug('Upgrading socket connection to TLS');\n                    const servername = opts.servername || opts.host;\n                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), { socket,\n                        servername }));\n                }\n                return socket;\n            }\n            // Some other status code that's not 200... need to re-play the HTTP\n            // header \"data\" events onto the socket once the HTTP machinery is\n            // attached so that the node core `http` can parse and handle the\n            // error status code.\n            // Close the original socket, and a new \"fake\" socket is returned\n            // instead, so that the proxy doesn't get the HTTP request\n            // written to it (which may contain `Authorization` headers or other\n            // sensitive data).\n            //\n            // See: https://hackerone.com/reports/541502\n            socket.destroy();\n            const fakeSocket = new net_1.default.Socket({ writable: false });\n            fakeSocket.readable = true;\n            // Need to wait for the \"socket\" event to re-play the \"data\" events.\n            req.once('socket', (s) => {\n                debug('replaying proxy buffer for failed request');\n                assert_1.default(s.listenerCount('data') > 0);\n                // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n                // this point the HTTP module machinery has been hooked up for\n                // the user.\n                s.push(buffered);\n                s.push(null);\n            });\n            return fakeSocket;\n        });\n    }\n}\nexports[\"default\"] = HttpsProxyAgent;\nfunction resume(socket) {\n    socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n    return Boolean((!secure && port === 80) || (secure && port === 443));\n}\nfunction isHTTPS(protocol) {\n    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;\n}\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for (key in obj) {\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n//# sourceMappingURL=agent.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxnR0FBWTtBQUN6QywrQ0FBK0MsbUJBQU8sQ0FBQyw4SEFBd0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsZ0NBQWdDLFVBQVUsR0FBRyxVQUFVO0FBQ3ZELHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQSwwREFBMEQsMkNBQTJDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSw0QkFBNEIsS0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLLElBQUksY0FBYztBQUNyRDtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxREFBcUQ7QUFDcEksb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFuaXNoLWxhbmd1YWdlLWxlYXJuaW5nLWFwcC8uL25vZGVfbW9kdWxlcy90ZWVueS1yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L2FnZW50LmpzP2RhNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5ldF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgdGxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRsc1wiKSk7XG5jb25zdCB1cmxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidXJsXCIpKTtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYWdlbnRfYmFzZV8xID0gcmVxdWlyZShcImFnZW50LWJhc2VcIik7XG5jb25zdCBwYXJzZV9wcm94eV9yZXNwb25zZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLXByb3h5LXJlc3BvbnNlXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdodHRwcy1wcm94eS1hZ2VudDphZ2VudCcpO1xuLyoqXG4gKiBUaGUgYEh0dHBzUHJveHlBZ2VudGAgaW1wbGVtZW50cyBhbiBIVFRQIEFnZW50IHN1YmNsYXNzIHRoYXQgY29ubmVjdHMgdG9cbiAqIHRoZSBzcGVjaWZpZWQgXCJIVFRQKHMpIHByb3h5IHNlcnZlclwiIGluIG9yZGVyIHRvIHByb3h5IEhUVFBTIHJlcXVlc3RzLlxuICpcbiAqIE91dGdvaW5nIEhUVFAgcmVxdWVzdHMgYXJlIGZpcnN0IHR1bm5lbGVkIHRocm91Z2ggdGhlIHByb3h5IHNlcnZlciB1c2luZyB0aGVcbiAqIGBDT05ORUNUYCBIVFRQIHJlcXVlc3QgbWV0aG9kIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHByb3h5IHNlcnZlcixcbiAqIGFuZCB0aGVuIHRoZSBwcm94eSBzZXJ2ZXIgY29ubmVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIHRhcmdldCBhbmQgaXNzdWVzIHRoZVxuICogSFRUUCByZXF1ZXN0IGZyb20gdGhlIHByb3h5IHNlcnZlci5cbiAqXG4gKiBgaHR0cHM6YCByZXF1ZXN0cyBoYXZlIHRoZWlyIHNvY2tldCBjb25uZWN0aW9uIHVwZ3JhZGVkIHRvIFRMUyBvbmNlXG4gKiB0aGUgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgc2VydmVyIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmNsYXNzIEh0dHBzUHJveHlBZ2VudCBleHRlbmRzIGFnZW50X2Jhc2VfMS5BZ2VudCB7XG4gICAgY29uc3RydWN0b3IoX29wdHMpIHtcbiAgICAgICAgbGV0IG9wdHM7XG4gICAgICAgIGlmICh0eXBlb2YgX29wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRzID0gdXJsXzEuZGVmYXVsdC5wYXJzZShfb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRzID0gX29wdHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FuIEhUVFAoUykgcHJveHkgc2VydmVyIGBob3N0YCBhbmQgYHBvcnRgIG11c3QgYmUgc3BlY2lmaWVkIScpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdjcmVhdGluZyBuZXcgSHR0cHNQcm94eUFnZW50IGluc3RhbmNlOiAlbycsIG9wdHMpO1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICAgICAgLy8gSWYgYHRydWVgLCB0aGVuIGNvbm5lY3QgdG8gdGhlIHByb3h5IHNlcnZlciBvdmVyIFRMUy5cbiAgICAgICAgLy8gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgICAgdGhpcy5zZWN1cmVQcm94eSA9IG9wdHMuc2VjdXJlUHJveHkgfHwgaXNIVFRQUyhwcm94eS5wcm90b2NvbCk7XG4gICAgICAgIC8vIFByZWZlciBgaG9zdG5hbWVgIG92ZXIgYGhvc3RgLCBhbmQgc2V0IHRoZSBgcG9ydGAgaWYgbmVlZGVkLlxuICAgICAgICBwcm94eS5ob3N0ID0gcHJveHkuaG9zdG5hbWUgfHwgcHJveHkuaG9zdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm94eS5wb3J0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcHJveHkucG9ydCA9IHBhcnNlSW50KHByb3h5LnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3h5LnBvcnQgJiYgcHJveHkuaG9zdCkge1xuICAgICAgICAgICAgcHJveHkucG9ydCA9IHRoaXMuc2VjdXJlUHJveHkgPyA0NDMgOiA4MDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBTFBOIGlzIHN1cHBvcnRlZCBieSBOb2RlLmpzID49IHY1LlxuICAgICAgICAvLyBhdHRlbXB0IHRvIG5lZ290aWF0ZSBodHRwLzEuMSBmb3IgcHJveHkgc2VydmVycyB0aGF0IHN1cHBvcnQgaHR0cC8yXG4gICAgICAgIGlmICh0aGlzLnNlY3VyZVByb3h5ICYmICEoJ0FMUE5Qcm90b2NvbHMnIGluIHByb3h5KSkge1xuICAgICAgICAgICAgcHJveHkuQUxQTlByb3RvY29scyA9IFsnaHR0cCAxLjEnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJveHkuaG9zdCAmJiBwcm94eS5wYXRoKSB7XG4gICAgICAgICAgICAvLyBJZiBib3RoIGEgYGhvc3RgIGFuZCBgcGF0aGAgYXJlIHNwZWNpZmllZCB0aGVuIGl0J3MgbW9zdCBsaWtlbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXN1bHQgb2YgYSBgdXJsLnBhcnNlKClgIGNhbGwuLi4gd2UgbmVlZCB0byByZW1vdmUgdGhlXG4gICAgICAgICAgICAvLyBgcGF0aGAgcG9ydGlvbiBzbyB0aGF0IGBuZXQuY29ubmVjdCgpYCBkb2Vzbid0IGF0dGVtcHQgdG8gb3BlblxuICAgICAgICAgICAgLy8gdGhhdCBhcyBhIFVuaXggc29ja2V0IGZpbGUuXG4gICAgICAgICAgICBkZWxldGUgcHJveHkucGF0aDtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm94eS5wYXRobmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3h5ID0gcHJveHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhXG4gICAgICogbmV3IEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsbGJhY2socmVxLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3h5LCBzZWN1cmVQcm94eSB9ID0gdGhpcztcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXIuXG4gICAgICAgICAgICBsZXQgc29ja2V0O1xuICAgICAgICAgICAgaWYgKHNlY3VyZVByb3h5KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gdGxzXzEuZGVmYXVsdC5jb25uZWN0KHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvJywgcHJveHkpO1xuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldF8xLmRlZmF1bHQuY29ubmVjdChwcm94eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJveHkuaGVhZGVycyk7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IGAke29wdHMuaG9zdH06JHtvcHRzLnBvcnR9YDtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gYENPTk5FQ1QgJHtob3N0bmFtZX0gSFRUUC8xLjFcXHJcXG5gO1xuICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBgUHJveHktQXV0aG9yaXphdGlvbmAgaGVhZGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChwcm94eS5hdXRoKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20ocHJveHkuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYEhvc3RgIGhlYWRlciBzaG91bGQgb25seSBpbmNsdWRlIHRoZSBwb3J0XG4gICAgICAgICAgICAvLyBudW1iZXIgd2hlbiBpdCBpcyBub3QgdGhlIGRlZmF1bHQgcG9ydC5cbiAgICAgICAgICAgIGxldCB7IGhvc3QsIHBvcnQsIHNlY3VyZUVuZHBvaW50IH0gPSBvcHRzO1xuICAgICAgICAgICAgaWYgKCFpc0RlZmF1bHRQb3J0KHBvcnQsIHNlY3VyZUVuZHBvaW50KSkge1xuICAgICAgICAgICAgICAgIGhvc3QgKz0gYDoke3BvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMuSG9zdCA9IGhvc3Q7XG4gICAgICAgICAgICBoZWFkZXJzLkNvbm5lY3Rpb24gPSAnY2xvc2UnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCArPSBgJHtuYW1lfTogJHtoZWFkZXJzW25hbWVdfVxcclxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm94eVJlc3BvbnNlUHJvbWlzZSA9IHBhcnNlX3Byb3h5X3Jlc3BvbnNlXzEuZGVmYXVsdChzb2NrZXQpO1xuICAgICAgICAgICAgc29ja2V0LndyaXRlKGAke3BheWxvYWR9XFxyXFxuYCk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGJ1ZmZlcmVkIH0gPSB5aWVsZCBwcm94eVJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXEub25jZSgnc29ja2V0JywgcmVzdW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zZWN1cmVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzb2NrZXQgY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lIHx8IG9wdHMuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRsc18xLmRlZmF1bHQuY29ubmVjdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9taXQob3B0cywgJ2hvc3QnLCAnaG9zdG5hbWUnLCAncGF0aCcsICdwb3J0JykpLCB7IHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlcm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSBvdGhlciBzdGF0dXMgY29kZSB0aGF0J3Mgbm90IDIwMC4uLiBuZWVkIHRvIHJlLXBsYXkgdGhlIEhUVFBcbiAgICAgICAgICAgIC8vIGhlYWRlciBcImRhdGFcIiBldmVudHMgb250byB0aGUgc29ja2V0IG9uY2UgdGhlIEhUVFAgbWFjaGluZXJ5IGlzXG4gICAgICAgICAgICAvLyBhdHRhY2hlZCBzbyB0aGF0IHRoZSBub2RlIGNvcmUgYGh0dHBgIGNhbiBwYXJzZSBhbmQgaGFuZGxlIHRoZVxuICAgICAgICAgICAgLy8gZXJyb3Igc3RhdHVzIGNvZGUuXG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgb3JpZ2luYWwgc29ja2V0LCBhbmQgYSBuZXcgXCJmYWtlXCIgc29ja2V0IGlzIHJldHVybmVkXG4gICAgICAgICAgICAvLyBpbnN0ZWFkLCBzbyB0aGF0IHRoZSBwcm94eSBkb2Vzbid0IGdldCB0aGUgSFRUUCByZXF1ZXN0XG4gICAgICAgICAgICAvLyB3cml0dGVuIHRvIGl0ICh3aGljaCBtYXkgY29udGFpbiBgQXV0aG9yaXphdGlvbmAgaGVhZGVycyBvciBvdGhlclxuICAgICAgICAgICAgLy8gc2Vuc2l0aXZlIGRhdGEpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9oYWNrZXJvbmUuY29tL3JlcG9ydHMvNTQxNTAyXG4gICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgY29uc3QgZmFrZVNvY2tldCA9IG5ldyBuZXRfMS5kZWZhdWx0LlNvY2tldCh7IHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGZha2VTb2NrZXQucmVhZGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gTmVlZCB0byB3YWl0IGZvciB0aGUgXCJzb2NrZXRcIiBldmVudCB0byByZS1wbGF5IHRoZSBcImRhdGFcIiBldmVudHMuXG4gICAgICAgICAgICByZXEub25jZSgnc29ja2V0JywgKHMpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygncmVwbGF5aW5nIHByb3h5IGJ1ZmZlciBmb3IgZmFpbGVkIHJlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRfMS5kZWZhdWx0KHMubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSBcImJ1ZmZlcmVkXCIgQnVmZmVyIG9udG8gdGhlIGZha2UgYHNvY2tldGAsIHNpbmNlIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBwb2ludCB0aGUgSFRUUCBtb2R1bGUgbWFjaGluZXJ5IGhhcyBiZWVuIGhvb2tlZCB1cCBmb3JcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICBzLnB1c2goYnVmZmVyZWQpO1xuICAgICAgICAgICAgICAgIHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZha2VTb2NrZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIHJlc3VtZShzb2NrZXQpIHtcbiAgICBzb2NrZXQucmVzdW1lKCk7XG59XG5mdW5jdGlvbiBpc0RlZmF1bHRQb3J0KHBvcnQsIHNlY3VyZSkge1xuICAgIHJldHVybiBCb29sZWFuKCghc2VjdXJlICYmIHBvcnQgPT09IDgwKSB8fCAoc2VjdXJlICYmIHBvcnQgPT09IDQ0MykpO1xufVxuZnVuY3Rpb24gaXNIVFRQUyhwcm90b2NvbCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnID8gL15odHRwczo/JC9pLnRlc3QocHJvdG9jb2wpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBvbWl0KG9iaiwgLi4ua2V5cykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2VudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/https-proxy-agent/dist/index.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/agent.js\"));\nfunction createHttpsProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function (createHttpsProxyAgent) {\n    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;\n    createHttpsProxyAgent.prototype = agent_1.default.prototype;\n})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));\nmodule.exports = createHttpsProxyAgent;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsZ0dBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYW5pc2gtbGFuZ3VhZ2UtbGVhcm5pbmctYXBwLy4vbm9kZV9tb2R1bGVzL3RlZW55LXJlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHBzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/NjY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGFnZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYWdlbnRcIikpO1xuZnVuY3Rpb24gY3JlYXRlSHR0cHNQcm94eUFnZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdChvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlSHR0cHNQcm94eUFnZW50KSB7XG4gICAgY3JlYXRlSHR0cHNQcm94eUFnZW50Lkh0dHBzUHJveHlBZ2VudCA9IGFnZW50XzEuZGVmYXVsdDtcbiAgICBjcmVhdGVIdHRwc1Byb3h5QWdlbnQucHJvdG90eXBlID0gYWdlbnRfMS5kZWZhdWx0LnByb3RvdHlwZTtcbn0pKGNyZWF0ZUh0dHBzUHJveHlBZ2VudCB8fCAoY3JlYXRlSHR0cHNQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSHR0cHNQcm94eUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/parse-proxy-response.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/teeny-request/node_modules/https-proxy-agent/dist/parse-proxy-response.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\nfunction parseProxyResponse(socket) {\n    return new Promise((resolve, reject) => {\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\n        // the CONNECT response, so that if the response is anything other than an \"200\"\n        // response code, then we can re-play the \"data\" events on the socket once the\n        // HTTP parser is hooked up...\n        let buffersLength = 0;\n        const buffers = [];\n        function read() {\n            const b = socket.read();\n            if (b)\n                ondata(b);\n            else\n                socket.once('readable', read);\n        }\n        function cleanup() {\n            socket.removeListener('end', onend);\n            socket.removeListener('error', onerror);\n            socket.removeListener('close', onclose);\n            socket.removeListener('readable', read);\n        }\n        function onclose(err) {\n            debug('onclose had error %o', err);\n        }\n        function onend() {\n            debug('onend');\n        }\n        function onerror(err) {\n            cleanup();\n            debug('onerror %o', err);\n            reject(err);\n        }\n        function ondata(b) {\n            buffers.push(b);\n            buffersLength += b.length;\n            const buffered = Buffer.concat(buffers, buffersLength);\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n            if (endOfHeaders === -1) {\n                // keep buffering\n                debug('have not received end of HTTP headers yet...');\n                read();\n                return;\n            }\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n            const statusCode = +firstLine.split(' ')[1];\n            debug('got proxy server response: %o', firstLine);\n            resolve({\n                statusCode,\n                buffered\n            });\n        }\n        socket.on('error', onerror);\n        socket.on('close', onclose);\n        socket.on('end', onend);\n        read();\n    });\n}\nexports[\"default\"] = parseProxyResponse;\n//# sourceMappingURL=parse-proxy-response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVlbnktcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cHMtcHJveHktYWdlbnQvZGlzdC9wYXJzZS1wcm94eS1yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFuaXNoLWxhbmd1YWdlLWxlYXJuaW5nLWFwcC8uL25vZGVfbW9kdWxlcy90ZWVueS1yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwcy1wcm94eS1hZ2VudC9kaXN0L3BhcnNlLXByb3h5LXJlc3BvbnNlLmpzPzNlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2UnKTtcbmZ1bmN0aW9uIHBhcnNlUHJveHlSZXNwb25zZShzb2NrZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGJ1ZmZlciBhbnkgSFRUUCB0cmFmZmljIHRoYXQgaGFwcGVucyB3aXRoIHRoZSBwcm94eSBiZWZvcmUgd2UgZ2V0XG4gICAgICAgIC8vIHRoZSBDT05ORUNUIHJlc3BvbnNlLCBzbyB0aGF0IGlmIHRoZSByZXNwb25zZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGFuIFwiMjAwXCJcbiAgICAgICAgLy8gcmVzcG9uc2UgY29kZSwgdGhlbiB3ZSBjYW4gcmUtcGxheSB0aGUgXCJkYXRhXCIgZXZlbnRzIG9uIHRoZSBzb2NrZXQgb25jZSB0aGVcbiAgICAgICAgLy8gSFRUUCBwYXJzZXIgaXMgaG9va2VkIHVwLi4uXG4gICAgICAgIGxldCBidWZmZXJzTGVuZ3RoID0gMDtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICAgICAgY29uc3QgYiA9IHNvY2tldC5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICBvbmRhdGEoYik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uY2UoJ3JlYWRhYmxlJywgcmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb25jbG9zZSBoYWQgZXJyb3IgJW8nLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgZGVidWcoJ29uZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGRlYnVnKCdvbmVycm9yICVvJywgZXJyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uZGF0YShiKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goYik7XG4gICAgICAgICAgICBidWZmZXJzTGVuZ3RoICs9IGIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIGJ1ZmZlcnNMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gYnVmZmVyZWQuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgICBpZiAoZW5kT2ZIZWFkZXJzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgYnVmZmVyaW5nXG4gICAgICAgICAgICAgICAgZGVidWcoJ2hhdmUgbm90IHJlY2VpdmVkIGVuZCBvZiBIVFRQIGhlYWRlcnMgeWV0Li4uJyk7XG4gICAgICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGJ1ZmZlcmVkLnRvU3RyaW5nKCdhc2NpaScsIDAsIGJ1ZmZlcmVkLmluZGV4T2YoJ1xcclxcbicpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSArZmlyc3RMaW5lLnNwbGl0KCcgJylbMV07XG4gICAgICAgICAgICBkZWJ1ZygnZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8nLCBmaXJzdExpbmUpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICBidWZmZXJlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgICAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgICAgIHNvY2tldC5vbignZW5kJywgb25lbmQpO1xuICAgICAgICByZWFkKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVByb3h5UmVzcG9uc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1wcm94eS1yZXNwb25zZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/teeny-request/node_modules/https-proxy-agent/dist/parse-proxy-response.js\n");

/***/ })

};
;